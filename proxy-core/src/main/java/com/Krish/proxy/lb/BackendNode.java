package com.krish.proxy.lb;

import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Represents a backend server node used by the load balancer.
 *
 * <p>
 * Design notes:
 * <ul>
 * <li>Identity fields ({@code id}, {@code host}, {@code port}, {@code weight})
 * are immutable.</li>
 * <li>Connection accounting uses {@link AtomicInteger} for thread-safety.</li>
 * <li>Health flag is {@code volatile} for lightweight visibility across
 * threads.</li>
 * </ul>
 *
 * <p>
 * Typical usage:
 * 
 * <pre>
 * BackendNode node = new BackendNode("10.0.0.5", 8080, 2);
 * node.incrementActiveConns();
 * try {
 *     // route request to node
 * } finally {
 *     node.decrementActiveConns();
 * }
 * </pre>
 */
public final class BackendNode {

    private final String id;
    private final String host;
    private final int port;
    private final int weight;
    private final AtomicInteger activeConns = new AtomicInteger(0);

    // Volatile boolean for simple health toggles; upgrade to
    // AtomicReference<HealthState>
    // if you need richer transitions (DRAINING, PROBING, etc.).
    private volatile boolean healthy;

    /**
     * Create a backend node with an autogenerated UUID id and initially healthy
     * state.
     *
     * @param host   hostname or IP address (non-null, non-blank)
     * @param port   TCP port (1..65535)
     * @param weight positive integer weight (>= 1)
     * @throws IllegalArgumentException if any argument is invalid
     */
    public BackendNode(String host, int port, int weight) {
        this(host, port, weight, UUID.randomUUID().toString(), true);
    }

    /**
     * Create a backend node with explicit id and initial health state.
     *
     * @param host             hostname or IP (non-null, non-blank)
     * @param port             TCP port (1..65535)
     * @param weight           positive integer weight (>=1)
     * @param id               unique identifier (non-null, non-blank)
     * @param initiallyHealthy initial health flag
     * @throws IllegalArgumentException if any argument is invalid
     */
    public BackendNode(String host, int port, int weight, String id, boolean initiallyHealthy) {
        if (host == null || host.isBlank()) {
            throw new IllegalArgumentException("host must be non-empty");
        }
        if (port < 1 || port > 0xFFFF) {
            throw new IllegalArgumentException("port out of range");
        }
        if (weight < 1) {
            throw new IllegalArgumentException("weight must be >= 1");
        }
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("id must be non-empty");
        }

        this.host = host;
        this.port = port;
        this.weight = weight;
        this.id = id;
        this.healthy = initiallyHealthy;
    }

    /**
     * Returns the unique identifier for this backend node.
     *
     * @return node id
     */
    public String id() {
        return id;
    }

    /**
     * Returns the backend host (IP or hostname).
     *
     * @return host
     */
    public String host() {
        return host;
    }

    /**
     * Returns the backend port.
     *
     * @return port
     */
    public int port() {
        return port;
    }

    /**
     * Returns the configured weight for weighted load balancing.
     *
     * @return weight
     */
    public int weight() {
        return weight;
    }

    /**
     * Returns a snapshot of the current active connection count.
     *
     * @return active connection count (>= 0)
     */
    public int activeConnections() {
        return activeConns.get();
    }

    /**
     * Atomically increments the active connection counter.
     * <p>
     * The load balancer should call this before assigning a request/connection to
     * this node.
     *
     * @return the new active connection count after increment
     */
    public int incrementActiveConns() {
        return activeConns.incrementAndGet();
    }

    /**
     * Atomically decrements the active connection counter in a CAS loop to avoid
     * negative counts.
     * <p>
     * The load balancer must call this in a finally block after request/connection
     * completes.
     *
     * @return the new active connection count after decrement (>= 0)
     */
    public int decrementActiveConns() {
        for (;;) {
            int current = activeConns.get();
            if (current == 0) {
                // defensively ensure counter doesn't go negative
                return 0;
            }
            if (activeConns.compareAndSet(current, current - 1)) {
                return current - 1;
            }
            // else retry
        }
    }

    /**
     * Returns whether this backend is currently considered healthy.
     *
     * @return true if healthy, false otherwise
     */
    public boolean isHealthy() {
        return healthy;
    }

    /**
     * Marks the node healthy (idempotent).
     */
    public void markHealthy() {
        this.healthy = true;
    }

    /**
     * Marks the node unhealthy (idempotent).
     */
    public void markUnhealthy() {
        this.healthy = false;
    }

    /**
     * Equality is defined by the unique {@code id} only.
     *
     * @param o other object
     * @return true if other is a BackendNode with the same id
     */
    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof BackendNode))
            return false;
        BackendNode other = (BackendNode) o;
        return id.equals(other.id);
    }

    /**
     * Hash code based on unique id.
     *
     * @return hash code
     */
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    /**
     * Human-readable representation including dynamic counters.
     *
     * @return string representation
     */
    @Override
    public String toString() {
        return "BackendNode{" +
                "id='" + id + '\'' +
                ", host='" + host + '\'' +
                ", port=" + port +
                ", weight=" + weight +
                ", activeConns=" + activeConns.get() +
                ", healthy=" + healthy +
                '}';
    }
}
